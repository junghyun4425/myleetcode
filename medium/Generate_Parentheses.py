# Problem Link: https://leetcode.com/problems/generate-parentheses/

'''
문제 요약: n개의 가능한, 열림과 닫힘이 정확히 맞는 괄호를 모두 나열하는 문제.
ask: 3
answer: ["((()))","(()())","(())()","()(())","()()()"]

해석:
괄호2개의 모양으로 만들수 있는 모든 경우의 수는 2^2n. 모든 경우의 수를 만들기 위해 for문 보다는 재귀식을 사용하는것이 효율적.
모든 경우의 수를 만들고, 완벽히 열리고 닫히는지 확인하기까지하면 해결. 하지만 여기서 쓸데없는 계산이 추가적으로 들어감.
예를 들어, 시작부터 ')' 들어가거나,')' 갯수가 n개이기도 전에 '('개수가 n개인 경우는 확인 할 필요가 없음.
따라서 규칙을 생각해 보면,
1 - 재귀함수를 호출할때 시작은 무조건 '('.
2 - '(' 개수 l, ')' 개수 r 을 재귀함수 인자로 추가.
3 - 재귀호출 처음은 '(' 이 n까지 나열.
4 - 그 이후는 r < l 까지 재귀로 ')' 를 추가. (r 갯수는 l을 넘길 수 없음)
5 - 길이가 맞으면 정답에 추가.
코드는 간단해 보이지만 규칙을 정확하게 찾는데 시간이 꽤 걸림. 다시풀어보기.

Review
다시 풀어보는데도 잠깐 막혔던 문제. 아직 재귀에 많이 약한편인것 같다는 생각.
막혔던 부분을 보자면, l < n 까지 '('을 추가하는것 까진 괜찮았는데
r < n 까지 ')' 을 추가해버리니까 완전하지 못한 parentheses들이 나옴.
빠르게 생각해서 r <= l 로 바꿔봤지만 오답. 여기에 equal 부등식을 넣어버렸다는 실수를 못찾아서 조금 오래 걸림.
equal을 넣으면 안되는 이유는 실제 l이 ((( 인경우 3의값을 지니고, r은 ))) 때 3의값을 지니므로 같으면 하나더 추가해버림.
이런 실수하지 않도록 부등호에 좀 더 신경써야함. (결과적으로 코드는 비슷해서 따로 추가하진 않음)
'''

class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        def checkAndGenerate(a='', l=0, r=0):
            if len(a) == 2 * n:
                ans.append(a)
            if l < n:
                checkAndGenerate(a + '(', l + 1, r)
            if r < l:
                checkAndGenerate(a + ')', l, r + 1)

        ans = []
        checkAndGenerate()
        return ans